<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<title>HTTP&nbsp;: les cas d'utilisation</title>
	<meta name="author" content="David Gayerie">
	<link href="css/article.css" rel="stylesheet" media="screen">
	<link href="css/print-article.css" rel="stylesheet" media="print">
	<link href="highlight/styles/zenburn.css" rel="stylesheet">
	
	<script src="highlight/highlight.pack.js"></script>
	<script>hljs.initHighlightingOnLoad();</script>
	<script src="js/toc.js"></script>
</head>
<body>
	<div id="titleBar">
		<a href="index.html" title="Retourner au sommaire"><img src="assets/go-home.png"></a>
 		<a href="https://github.com/spoonless/epsi-i4-web-services/archive/gh-pages.zip" title="Télécharger tout le cours"><img src="assets/download.png"></a>
		Web Services - EPSI I4 2015/2016 - <a href="mailto:david.gayerie.epsi@mailoo.org">David Gayerie</a>
	</div>

	<header></header>
	<article>
		<h1><script>document.write(document.title)</script></h1>
		<section id="toc"></section>

		<section>
			<p>&Agrave; travers différents cas d'utilisation, nous allons exploiter différents codes statut et introduire de nouveaux en-têtes HTTP.</p>
			
			<h2>Création d'une ressource dont on connait l'URI</h2>
			
			<p>Lorsqu'un client veut créer une ressource sur le serveur, il faut distinguer le cas où le client connaît
			l'URI finale de la ressource du cas où c'est au serveur de déterminer l'URI finale. Dans le cas où l'utilisateur
			connaît l'URI, la méthode sera <strong>toujours</strong> un <code>PUT</code>. En cas de succès, le serveur devrait répondre
			le code 201.</p>
			
			<figure>
				<figcaption>La requête</figcaption>
				<pre><code class="http">PUT /individu/David+Gayerie HTTP/1.1
Host: exemple.fr
Content-Type: application/json; charset=utf-8
Content-Length: 91

{'name' : 'Gayerie', 
 'firstname' : 'David', 
 'email' : 'david.gayerie.epsi@mailoo.org'}</code></pre>

			</figure>
			<figure>
				<figcaption>La réponse du serveur en cas de succès</figcaption>
				<pre><code class="http">HTTP/1.1 201 Created
				</code></pre>
			</figure>			

			<h2>Création d'une ressource dont on ne connait pas l'URI</h2>
			<p>Dans le cas où l'utilisateur ne connaît pas l'URI finale de la ressource, 
			la méthode sera <strong>toujours</strong> un <code>POST</code>. En cas de succès, le serveur devrait répondre
			le code 201 et un en-tête <code>Location</code> donnant au client l'URI de la nouvelle ressource.</p>

			<figure>
				<figcaption>La requête</figcaption>
				<pre><code class="http">POST /individu/ HTTP/1.1
Host: exemple.fr
Content-Type: application/x-www-form-urlencoded; charset=utf-8
Content-Length: 65

name=Gayerie&amp;firstname=David&amp;email=david.gayerie.epsi@mailoo.org</code></pre>
			</figure>
			<figure>
				<figcaption>La réponse du serveur en cas de succès</figcaption>
				<pre><code class="http">HTTP/1.1 201 Created
Location: http://exemple.fr/individu/000001

</code></pre>
			</figure>
			
			<h2>Suppression de l'accès à la ressource</h2>
			
			<figure>
				<figcaption>La requête</figcaption>
				<pre><code class="http">DELETE /individu/000001 HTTP/1.1
Host: exemple.fr

</code></pre>
			</figure>
			<figure>
				<figcaption>La réponse du serveur en cas de succès</figcaption>
				<pre><code class="http">HTTP/1.1 204 No content

</code></pre>
			</figure>
			
			<h2>Le traitement asynchrone d'une requête</h2>
			
			<p>Parfois, le serveur ne peut pas traiter complètement une requête dans un temps acceptable. Dans ce cas,
			il peut retourner le code 202 qui signifie qu'il a bien compris et accepté la requête mais
			qu'il ne l'a pas encore traitée. L'en-tête <code>Location</code> pointe sur une URI où
			le client pourra se rendre pour consulter l'état du traitement.</p>

			<figure>
				<figcaption>La requête</figcaption>
				<pre><code class="http">DELETE /individu/000001 HTTP/1.1
Host: exemple.fr

</code></pre>
			</figure>
			<figure>
				<figcaption>La réponse du serveur lorsque la requête est traitée en asynchrone</figcaption>
				<pre><code class="http">HTTP/1.1 202 Accepted
Location: http://exemple.fr/jobs/1948321

</code></pre>
			</figure>
			
			<h2>La négociation de contenu proactive</h2>
			
			<p>Parfois, un serveur peut disposer de plusieurs représentations pour une même ressource. Par exemple, il peut
			présenter un série de données dans une page HTML et sous un format CSV. Le client peut alors
			suggérer au serveur une liste de formats MIME correspondant à ses préférences. C'est ce que l'on appelle
			la négociation de contenu proactive. L'en-tête <a href="http://tools.ietf.org/html/rfc7231#section-5.3.2"><code>Accept</code></a>
			permet au client de fournir une liste de types MIME séparés par une virgule. Bien évidemment, l'en-tête
			<code>Accept</code> n'a de sens que si le client s'attend à recevoir une représentation de la part du serveur
			(ou s'il utilise la méthode <code>HEAD</code> pour tester l'existence de ce format).</p>
			
			<figure>
				<figcaption>Négociation de contenu sur le format de la représentation</figcaption>
				<pre><code class="http">GET /individu/00001 HTTP/1.1
Host: www.monserveur.fr
Accept: text/html,text/plain,application/pdf

</code></pre>
			</figure>
			
			<p>Dans l'exemple précédent, l'ordre dans la liste n'a pas d'importance, le client annonce au serveur
			qu'il peut indifféremment fournir une représentation au format HTML, texte brut ou un document PDF.
			Si le serveur ne dispose d'aucune de ces représentations, il répondra un code statut <strong>415</strong> (Unsupported Media Type).</p>
			
			<aside>
				<p>Le client peut affiner sa négociation en annonçant que si plusieurs représentations sont disponibles,
				certaines seront préférées à d'autres. Cela se fait à l'aide du paramètre <strong>q</strong> qui donne
				une pondération entre 0 et 1. Lorsque le paramètre <code>q</code> n'est pas précisé, sa valeur
				implicite est 1 (la plus forte préférence).</p>
				<figure>
					<figcaption>Négociation de contenu avec pondération des formats</figcaption>
					<pre><code class="http">GET /individu/00001 HTTP/1.1
Host: www.monserveur.fr
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8

</code></pre>
				</figure>
				<p>Dans l'exemple précédent, le client annonce au serveur qu'il préfére les formats HTML et XHTML (q=1 est ici implicite)
				au format XML simple (q=0.9). Sinon il accepte de recevoir n'importe quel format (*/*;q=0.8). Ainsi, si un serveur
				dispose d'une représentation HTML, XML et PDF pour une ressource, il doit retourner à ce client le format HTML.
				Notez que cette valeur de l'en-tête <code>Accept</code> est celle par défaut du navigateur Firefox.</p>
			</aside>
			
			<p>Le client peut également établir une négociation avec le serveur sur le type d'encodage du document (grâce à l'en-tête <a href="http://tools.ietf.org/html/rfc7231#section-5.3.3"><code>Accept-Charset</code></a>)
			ou sur la langue utilisée dans le document <a href="http://tools.ietf.org/html/rfc7231#section-5.3.5"><code>Accept-Language</code></a>).
			Si le serveur ne peut pas satisfaire les exigences du client dans ces cas, il est tout de même sensé retourner ce qu'il
			juge la meilleure réponse afin de ne pas empêcher l'utilisateur d'accéder à l'information.</p>

			<figure>
				<figcaption>Négociation de contenu sur la langue du document</figcaption>
				<pre><code class="http">GET /individu/00001 HTTP/1.1
Host: www.monserveur.fr
Accept-Language: fr,fr-fr;q=0.8,en-us;q=0.5,en;q=0.3

</code></pre>
			</figure>
			
			<h2>Les requêtes conditionnelles</h2>
			<p>Les requêtes conditionnelles permettent au client de préciser dans les en-têtes de requête des conditions
			qui, selon qu'elles sont vraies ou fausses, doivent changer le comportement du serveur.
			Les requêtes conditionnelles sont utilisées dans deux cas&nbsp;:
			</p>
			<ul>
				<li>Pour la gestion de cache lors d'une requête GET, le client demande au serveur de lui retourner la 
				représentation de la ressource si cette dernière diffère de la version dont le client dispose déjà.</li>
				<li>Pour garantir l'intégrité des données lors d'une requête non sûre (PUT, POST, PATCH ou DELETE), 
				le client désire que l'action soit effectuée uniquement si la ressource n'a pas été modifiée depuis
				son dernier accès.</li>
			</ul>
			
			<p>Les requêtes conditionnelles peuvent se baser sur la date de dernière modification de la ressource que
			le serveur est sensé communiqué (principalement en réponse à une requête GET ou HEAD) grâce à l'en-tête
			de réponse <a href="http://tools.ietf.org/html/rfc7232#section-2.2"><code>Last-Modified</code></a>.</p>

			<figure>
				<figcaption>Une réponse HTTP avec l'en-tête <code>Last-Modified</code></figcaption>
				<pre><code class="http">HTTP/1.1 200 OK
Content-Type: text/plain; charset=utf-8
Content-Length: 17
Last-Modified: <script type="text/javascript">document.write(new Date().toUTCString())</script>

Hello the world!

</code></pre>
			</figure>
			
			<p>Les requêtes conditionnelles peuvent également se baser sur l'<code>Entity-Tag</code>. L'<code>Entity-Tag</code>
			est une chaîne de caractères (délimitée par ") que le serveur peut communiquer (principalement en réponse à une requête GET ou HEAD)
			grâce à l'en-tête de réponse <a href="http://tools.ietf.org/html/rfc7232#section-2.3"><code>ETag</code></a>.
			Ce tag reste identique tant que la ressource ou sa représentation associée n'ont pas été modifiées.
			L'<code>Entity-Tag</code> est opaque pour le client et ce dernier n'a pas besoin de connaître l'algorithme
			utilisé par le serveur pour produire.</p>
				
			<figure>
				<figcaption>Une réponse HTTP avec l'en-tête <code>ETag</code></figcaption>
				<pre><code class="http">HTTP/1.1 200 OK
Content-Type: text/plain; charset=utf-8
Content-Length: 17
ETag: "<script>document.write(Math.random().toString(16).substring(2))</script>"

Hello the world!

</code></pre>
			</figure>
			
			<aside class="tip">
				<p><code>Last-Modified</code> et <code>ETag</code> ne sont normalement pas fournis
				par le serveur en réponse à la création ou la modification d'une ressource. En effet, la représentation
				transmise par le client <i>via</i> une méthode <code>PUT</code> ou <code>POST</code>
				peut ne pas correspondre exactement à la représentation qui sera retournée par le serveur lors d'une
				requête <code>GET</code>. En effet, le serveur ajoute souvent des informations à la ressource
				lors de sa création. Il est donc communément admis que la représentation de la ressource envoyée par
				le client ne peut pas être considérée comme fiable. Pour éviter toute mise en cache prématurée,
				le serveur ne renvoie donc pas les en-têtes <code>Last-Modified</code> et <code>ETag</code>.</p>
			</aside>
			
			<h2>Demander une représentation à jour</h2>
			<p>Lorsque le client dispose déjà d'une représentation de la resource, il peut demander au serveur de lui
			retourner une nouvelle représentation uniquement si celle-ci diffère celle en cache. L'intérêt principal
			et de limiter la consommation de bande passante. Mais cela peut aussi être un moyen de savoir si la ressource
			a été modifiée par un autre client ou un processus asynchrone. Pour ce cas d'utilisation, le client
			a besoin de connaître la date de dernière modification (obtenue grâce à l'en-tête de réponse <code>Last-Modified</code>)
			ou la valeur de l'<code>Entity-Tag</code> (obtenue grâce à l'en-tête de réponse <code>Etag</code>)</p>
			<p>Le client peut construire sa requête en utilisant l'un des en-têtes suivants&nbsp;:</p>

			<dl>
				<dt><a href="http://tools.ietf.org/html/rfc7232#section-3.3"><code>If-Modified-Since</code></a></dt>
				<dd>Permet de spécifier au serveur que la ressource doit avoir été modifiée depuis la date donnée pour traiter la requête.
				
					<figure>
						<figcaption>Requête conditionnelle avec <code>If-Modified-Since</code></figcaption>
						<pre><code class="http">GET /individu/00001 HTTP/1.1
Host: www.monserveur.fr
If-Modified-Since: <script type="text/javascript">document.write(new Date().toUTCString())</script>

</code></pre>
					</figure>
					<p>Si la ressource <strong>n'a pas été modifiée</strong> depuis cette date, le serveur devrait
					retourner le code <strong>304</strong> (Not modified) sans payload dans la réponse.</p>

					<figure>
						<figcaption>Réponse lorsque la ressource n'a pas été modifiée depuis la date donnée</figcaption>
						<pre><code class="http">HTTP/1.1 304 Not Modified

</code></pre>
					</figure>
					<p>Si la ressource a été effectivement modifiée, le serveur doit traiter la requête normalement.</p>
				</dd>

				<dt><a href="http://tools.ietf.org/html/rfc7232#section-3.2"><code>If-None-Match</code></a></dt>
				<dd>Permet de spécifier au serveur que la ressource doit avoir été modifiée depuis le dernier état connu pour traiter la requête.
				    Le client demande au serveur de comparer l'<code>Entity-Tag</code> de la représentation de la ressource
				    avec celui envoyé dans la requête.
				
					<figure>
						<figcaption>Requête conditionnelle avec <code>If-None-Match</code></figcaption>
						<pre><code class="http">GET /individu/00001 HTTP/1.1
Host: www.monserveur.fr
If-None-Match: "<script>document.write(Math.random().toString(16).substring(2))</script>"

</code></pre>
					</figure>
					<p>Si l'<code>Entity-Tag</code> de la représentation de la ressource <strong>correspond à celui envoyé</strong> par le client, 
					alors le serveur en déduit qu'il n'y a pas eu de modification et il devrait	retourner le code <strong>304</strong> (Not modified) sans payload dans la réponse.</p>

					<figure>
						<figcaption>Réponse lorsque l'<code>Entity-Tag</code> correspond à celui envoyé par le client</figcaption>
						<pre><code class="http">HTTP/1.1 304 Not Modified

</code></pre>
					</figure>
					<p>Si les <code>Entity-Tags</code> diffèrent,alors le serveur doit traiter la requête normalement.</p>
				</dd>
			</dl>

			<h2>Créer une ressource si elle n'existe pas déjà</h2>
			<p>La méthode <code>PUT</code> a une double sémantique de création et de mise à jour. Cependant, un client désire parfois créer
			uniquement une ressource et ne souhaite pas la modifier si elle existe déjà. Dans ce cas, on peut utiliser l'en-tête <code>If-None-Match</code>
			avec la valeur spéciale <code>*</code> (ce qui signifie que le serveur doit traiter la requête si aucune représentation de la ressource n'est disponible).</p>

			<figure>
				<figcaption>Requête de création uniquement</figcaption>
				<pre><code class="http">PUT /individu/David+Gayerie HTTP/1.1
Host: www.monserveur.fr
If-None-Match: *
Content-Type: application/x-www-form-urlencoded; charset=utf-8
Content-Length: 65

name=Gayerie&amp;firstname=David&amp;email=david.gayerie.epsi@mailoo.org</code></pre>
			</figure>
			
			<p>Si le serveur dispose d'une représentation pour cette ressource (et donc si elle existe déjà), il doit répondre un code <strong>412</strong> (Precondition Failed)&nbsp;:</p>
			<figure>
				<figcaption>Réponse lorsque la ressource existe déjà</figcaption>
				<pre><code class="http">HTTP/1.1 412 Precondition Failed

</code></pre>
			</figure>

			<h2>Altérer une ressource sous condition</h2>
			
			<p>Dans un environnement client/serveur, la mise à jour de données pose systématiquement un problème&nbsp;: comment savoir si les données
			que je mets à jour n'ont pas été altérées par un autre client depuis le dernier accès. Pour le Web, on trouve plusieurs solutions déclinant
			généralement les solutions du verrou optimiste ou pessimiste (optimistic/pessimistic lock). HTTP fournit un mécanisme de verrou optimiste
			grâce à différents en-têtes. Le client peut altérer une ressource avec une méthode <code>PUT</code>, <code>POST</code>, <code>PATCH</code>
			ou <code>DELETE</code> en spécifiant au serveur la condition de validité de la requête. Pour ce cas d'utilisation, le client
			a besoin de connaître la date de dernière modification (obtenue grâce à l'en-tête de réponse <code>Last-Modified</code>)
			ou la valeur de l'<code>Entity-Tag</code> (obtenue grâce à l'en-tête de réponse <code>Etag</code>)</p>
			<p>Le client peut construire sa requête en utilisant l'un des en-têtes suivants&nbsp;:</p>
			
			<dl>
				<dt><a href="http://tools.ietf.org/html/rfc7232#section-3.4"><code>If-Unmodified-Since</code></a></dt>
				<dd>Permet de spécifier au serveur que la ressource ne doit pas avoir été modifiée depuis la date donnée pour traiter la requête.
					<figure>
						<figcaption>Requête conditionnelle avec <code>If-Unmodified-Since</code></figcaption>
						<pre><code class="http">PUT /individu/David+Gayerie HTTP/1.1
Host: www.monserveur.fr
If-Unmodified-Since: <script type="text/javascript">document.write(new Date().toUTCString())</script>
Content-Type: application/x-www-form-urlencoded; charset=utf-8
Content-Length: 65

name=Gayerie&amp;firstname=David&amp;email=david.gayerie.epsi@mailoo.org</code></pre>
					</figure>

					<p>Si la ressource a effectivement été modifiée, le serveur doit retourner un code <strong>412</strong> (Precondition Failed)&nbsp;:</p>
					<figure>
						<figcaption>Réponse lorsque la ressource a été modifiée depuis la date donnée</figcaption>
						<pre><code class="http">HTTP/1.1 412 Precondition Failed

</code></pre>
					</figure>
				</dd>

				<dt><a href="http://tools.ietf.org/html/rfc7232#section-3.1"><code>If-Match</code></a></dt>
				<dd>Permet de spécifier au serveur que la ressource ne doit pas avoir été modifiée depuis le dernier état connu pour traiter la requête. 
				Le client demande au serveur de comparer l'<code>Entity-Tag</code> de la représentation de la ressource avec celui envoyé dans la requête.
				
					<figure>
						<figcaption>Requête conditionnelle avec <code>If-Match</code></figcaption>
						<pre><code class="http">PUT /individu/David+Gayerie HTTP/1.1
Host: www.monserveur.fr
If-Match: "<script>document.write(Math.random().toString(16).substring(2))</script>"
Content-Type: application/x-www-form-urlencoded; charset=utf-8
Content-Length: 65

name=Gayerie&amp;firstname=David&amp;email=david.gayerie.epsi@mailoo.org</code></pre>
					</figure>
					<p>Si l'<code>Entity-Tag</code> de la représentation de la ressource <strong>ne correspond pas à celui envoyé</strong> par le client, 
					alors le serveur en déduit qu'il n'y a eu une modification et il devrait retourner le code <strong>412</strong> 
					(Precondition failed) sans payload dans la réponse.</p>

					<figure>
						<figcaption>Réponse lorsque l'<code>Entity-Tag</code> ne correspond pas à celui envoyé par le client</figcaption>
						<pre><code class="http">HTTP/1.1 412 Precondition failed

</code></pre>
					</figure>
					<p>Si les <code>Entity-Tags</code> sont identiques,alors le serveur doit traiter la requête normalement.</p>

				</dd>
			</dl>

			<aside>
				<p>Si la ressource a été modifiée mais que le serveur est capable de déduire que l'état actuel est le
				même que celui résultant du traitement de la requête, alors le serveur peut retourner un code statut <strong>2XX</strong>.
				Ainsi la requête n'est pas traitée mais le résultat attendu par le client est déjà effectif.</p>
			</aside>
			
			<h2>Altérer une ressource si elle existe</h2>
			<p>Parfois, un client désire modifier une ressource et ne souhaite pas que sa requête soit traitée si elle n'existe pas. Dans ce cas, on peut utiliser l'en-tête <code>If-Match</code>
			avec la valeur spéciale <code>*</code> (ce qui signifie que le serveur doit traiter la requête si au moins une representation de la ressource est disponible).</p>

			<figure>
				<figcaption>Requête de modification uniquement</figcaption>
				<pre><code class="http">DELETE /individu/David+Gayerie HTTP/1.1
Host: www.monserveur.fr
If-Match: *

</code></pre>
			</figure>
			
			<p>Si le serveur ne dispose pas d'une représentation pour cette ressource (et donc si elle n'existe pas), il doit répondre un code <strong>412</strong> (Precondition Failed)&nbsp;:</p>
			<figure>
				<figcaption>Réponse lorsque la ressource n'existe pas</figcaption>
				<pre><code class="http">HTTP/1.1 412 Precondition Failed

</code></pre>
			</figure>
			
			
			<h2>Les redirections</h2>
			
			<p>Les redirections correspondent aux codes statut de la famille 3XX. Elles permettent au serveur de réorienter le client
			vers une nouvelle URI. &Agrave; la réception d'un code de redirection, le client doit comprendre que pour terminer sa requête, il doit
			exécuter une nouvelle requête vers une URI fournie dans la réponse par le serveur grâce à l'en-tête 
			<a href="http://tools.ietf.org/html/rfc7231#section-7.1.2"><code>Location</code></a>.</p>
			
			<h2>Evolutivité du service et modification des URI</h2>
			
			<p>Le cas le plus simple d'utilisation des redirections est celui où le serveur évolue dans le temps. Des évolutions peuvent
			entraîner une modification des URI. Plutôt que de retourner simplement une erreur, le serveur propose une redirection
			pour assurer une continuité du service. Dans ce cas, le serveur peut retourner une code statut <strong>301</strong> (Moved Permanently)
			avec un en-tête <code>Location</code> donnant la nouvelle URI.</p>

			<figure>
				<figcaption>Le serveur signale un changement de l'URI du service</figcaption>
				<pre><code class="http">HTTP/1.1 301 Moved Permanently
Location: http://mon.nouveau.serveur.fr/ma/ressource/cible

</code></pre>
			</figure>
			
			<h2>URI volatile et canonicalisation d'URI</h2>
			
			<p>Nous verrons que dans une architecture REST, une ressource ne doit être identifié que par une seule URI. Pourtant
			il existe de nombreux cas d'utilisation où l'on désire rendre accessible la representation d'une ressource à partir
			de différentes URI. Par exemple, imaginons une suite de news, chaque article dispose de sa propre URI mais on peut
			souhaiter exposer une URI permettant d'accéder au dernier article publié. Cette URI désignera forcément dans le temps
			des ressources différentes. Elle est volatile. Dans ce cas, le serveur peut retourner pour cette URI le code statut
			<strong>307</strong> (Temporary redirect) qui demande au client de refaire la même requête vers l'URI donnée en réponse
			par l'en-tête <code>Location</code>.</p>

			<figure>
				<figcaption>Requête sur une URI <i>volatile</i></figcaption>
				<pre><code class="http">GET /articles/latest HTTP/1.1
Host: www.mynews.fr

</code></pre>
			</figure>

			<figure>
				<figcaption>Redirection du serveur</figcaption>
				<pre><code class="http">HTTP/1.1 307 Temporary redirect
Location: http://www.mynews.fr/articles/les+nouvelles+du+monde.html

</code></pre>
			</figure>
			
			<aside>Pour une requête <code>GET</code>, la redirection est coûteuse car elle oblige le client
			à émettre une nouvelle requête vers le serveur. Si le serveur peut répondre directement, il peut renvoyer
			une code 2XX avec le payload attendu et ajouter l'en-tête de réponse <code>Content-Location</code> qui
			indique au client la véritable URI pour cette ressource (appelée URI canonique). 
				<figure>
					<figcaption>Canonicalisation grâce à l'en-tête <code>Content-Location</code></figcaption>
					<pre><code class="http">HTTP/1.1 200 OK
Content-Location: http://www.mynews.fr/articles/les+nouvelles+du+monde.html
Cache-Control: no-store
Content-Type: text/plain
Content-Length: 35

Il n'y pas de nouvelle du monde :(

</code></pre>
				</figure>
			</aside>
			
			<h2>Séparer le traitement de la requête de son résultat</h2>
			
			<p>Nous avons vu précédemment qu'il est possible de réaliser des requêtes asynchrones en HTTP.
			Mais il existe d'autres cas pour lesquels le serveur ne souhaite pas retourner directement de réponse au client.
			</p>
			<p>Dans la navigation Web, un cas répandu est le <a href="http://fr.wikipedia.org/wiki/Post-Redirect-Get">POST/Redirect/GET</a>.
			Une requête <code>POST</code> étant idempotente, lorsqu'un utilisateur remonte dans son historique de navigation, le navigateur n'a pas
			d'autre choix que de demander à l'utilisateur s'il désire soumettre à nouveau une requête <code>POST</code>. Il est donc souhaitable
			de faire disparaître les méthodes non idempotentes de l'historique de navigation. Or un navigateur Web ne conserve pas l'historique 
			d'une requête dont la réponse est une redirection (ou plus exactement, il lui substitue la requête de redirection). 
			Il est donc possible de supprimer les requêtes <code>POST</code> de l'historique de navigation
			en s'assurant que les réponses sont toujours des redirections avec une méthode <code>GET</code> vers une page de résultat&nbsp;: 
			il s'agit du modèle du POST/Redirect/GET. Pour cela, le développeur de site Web doit s'assurer que le code statut en réponse à une méthode
			<code>POST</code> est un code <strong>303</strong> (See Other). L'en-tête de réponse <code>Location</code> indique à quelle URI
			le client doit soumettre la requête <code>GET</code> de redirection.</p>
			
			<figure>
				<figcaption>Une requête <code>POST</code></figcaption>
				<pre><code class="http">POST /individu/ HTTP/1.1
Host: exemple.fr
Content-Type: application/x-www-form-urlencoded; charset=utf-8
Content-Length: 65

name=Gayerie&amp;firstname=David&amp;email=david.gayerie.epsi@mailoo.org</code></pre>
			</figure>
			<figure>
				<figcaption>La réponse du serveur avec une redirection</figcaption>
				<pre><code class="http">HTTP/1.1 303 See Other
Location: http://exemple.fr/individu/000001

</code></pre>
			</figure>

			<aside class="tip">
				<header>302, 303 et 307&nbsp;: quelles différences&nbsp;?</header>
				<p>HTTP définit trois codes statut de redirection assez proches&nbsp;: 302 (Found), 303 (See Other) et 307 (Temporary Redirect).
				Il existe cependant une différence majeure entre ces trois codes qui correspond à des cas d'utilisation différents.
				</p>
				<dl>
					<dt>302</dt>
					<dd>Il s'agit d'un code hérité de HTTP 1.0. Sa signification est ambiguë. C'est d'ailleurs pour cela
					que les codes 303 et 307 ont fait leur apparition dans HTTP 1.1. Pour une application serveur, il est
					déconseillé de s'en servir. Pour une application cliente, il est conseillé de le traiter comme un code statut 303</dd>

					<dt>303</dt>
					<dd>Ce code stipule que la requête <strong>a été traitée</strong> par le serveur. Cependant le client
					ne peut connaître le résultat que s'il soumet une requête <strong><code>GET</code></strong> à l'URI fournie en réponse dans l'en-tête <code>Location</code>.</dd>

					<dt>307</dt>
					<dd>Ce code stipule que la requête <strong>n'a pas été traitée</strong> par le serveur. Le client
					doit donc soumettre à nouveau <strong>la même</strong> requête quelle que soit la méthode à l'URI fournie 
					en réponse dans l'en-tête <code>Location</code>.</dd>
				</dl>
			</aside>
			
		</section>
	</article>
</body>
</html>