<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<title>REST</title>
	<meta name="author" content="David Gayerie">
	<link href="css/article.css" rel="stylesheet" media="screen">
	<link href="css/print-article.css" rel="stylesheet" media="print">
	<link href="highlight/styles/zenburn.css" rel="stylesheet">
	
	<script src="highlight/highlight.pack.js"></script> 
	<script>hljs.initHighlightingOnLoad();</script>
	<script src="js/toc.js"></script>
</head>
<body>
	<div id="titleBar">
		<a href="index.html" title="Retourner au sommaire"><img src="assets/go-home.png"></a>
 		<a href="https://github.com/spoonless/epsi-i4-web-services/archive/gh-pages.zip" title="Télécharger tout le cours"><img src="assets/download.png"></a>
		<script>document.write(document.title)</script> - EPSI I4 2014/2015 - <a href="mailto:david.gayerie.epsi@mailoo.org">David Gayerie</a>
	</div>
	<article>
		<h1><script>document.write(document.title)</script></h1>
		<section id="toc"></section>
		<section>
			<p>REST est un style d'architecture pour les systèmes hypermédia distribués.</p>
			<p>En 2000, Roy Fielding a formalisé l'architecture REST dans le chapitre 5 de sa <a href="http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm">thèse de doctorat</a>.
			En 2007, Leonard Richardson et Sam Ruby présentent ROA (Resource Oriented Architecture) dans leur ouvrage <em>RESTful Web Services</em>.
			ROA est devenu depuis le modèle d'application de REST pour les services Web.</p>
			
			<p>Le modèle REST a été conçu au moment de l'évolution de HTTP vers sa version 1.1 afin d'assurer les évolutions nécessaires du World Wide Web dans les années 1990.
			HTTP est ainsi le premier protocole basé sur une architecture REST.</p>
			<p><strong>REST est le modèle d'architecture du Web&nbsp;!</strong> Cela ne signifie pas que l'ensemble du Web
			se conforme au modèle décrit par REST mais cela signifie que HTTP a été conçu selon ce modèle (principalement
			pour des raisons de scalabilité et de fiabilité).</p>
		</section>
		
		<section>
			<h2>La ressource</h2>
			
			<p>REST est un style d'architecture <strong>orienté ressource</strong>. Mais qu'est-ce qu'une ressource&nbsp;?</p>
			
			<blockquote>
				<p>"Any information that can be named can be a resource" - Roy Fielding</p>
			</blockquote>
			
			<p>Dans le domaine du Web, la notion d'adressabilité (<i>addressability</i>) vient renforcer celle de nommage. 
			Une ressource est donc une information qui est adressable à partir d'une URI.</p>
			
			<aside>
				<p>Par exemple, ce cours est adressable à partir de l'URI 
				<script>document.write("<a class='explicit' href='" + window.location + "'>" + window.location + "</a>")</script></p>
			</aside>
			
			<p>Une ressource Web peut être accessible à partir de plusieurs URI. 
			Une bonne pratique consiste à considérer qu'une des URI est l'URI <em>canonique</em>.</p>
			<p>Par exemple une ressource peut être constituée par la liste des étudiants d'une promotion. Elle peut être adressable
			à partir d'une URI précise mais également d'une URI plus volatile comme celle donnant la liste des étudiants pour l'année en cours.
			Ces deux URI désignent la même ressource pendant une période&nbsp;:</p>
			<pre><code class="http">http://epsi.fr/bordeaux/informatique/i4/etudiants/<script>document.write(new Date().getFullYear())</script> (URI canonique)</code></pre>
			<pre><code class="http">http://epsi.fr/bordeaux/informatique/i4/etudiants/annee-courante</code></pre>
			
			<aside>
				<p>Nous avons vu dans les cas d'utilisation de HTTP, que la canonicalisation pouvait se traduire par une redirection
				avec un code statut 307 (Temporary Redirect) ou par l'en-tête de réponse <code>Content-Location</code>.</p>
			</aside>
			
			<h3>URI informative ou URI opaque ?</h3>
			
			<p>Une bonne pratique consiste à concevoir des URI descriptives et hiérarchiques. Par exemple, si l'on considère cette URI&nbsp;:</p>
	
			<pre><code class="http">http://epsi.fr/bordeaux/informatique/i4/etudiants/<script>document.write(new Date().getFullYear())</script></code></pre>
	
			<p>La structure de cette URI est porteuse d'information et le lecteur comprend facilement qu'elle suit un modèle du type&nbsp;:</p>
	
			<pre><code class="http">http://epsi.fr/{ville}/{spécialité}/{code année}/etudiants/{promotion}</code></pre>
	
			<p>Cette bonne pratique ne relève absolument pas d'une contrainte de l'architecture REST. Il s'agit souvent d'une erreur
			d'interprétation des développeurs de penser que REST repose avant tout sur la conception d'une API basée sur des chemins d'URI. 
			Une URI est simplement un nom donné à une ressource. Pour notre exemple, l'URI suivante est tout aussi valide&nbsp;:</p>
	
			<pre><code class="http">http://epsi.fr/b54adc00-67f9-11d9-9669-0800200c9a66</code></pre>
			
			<p>Dans une architecture REST, les URI peuvent être opaques, c'est-à-dire qu'elles ne portent pas nécessairement d'information
			sur la ressource qu'elles désignent, elles se limitent à la rendre adressable.</p>
			
			<h3>Ressource contre RPC</h3>
			
			<p>Il existe une autre grande famille de modèles d'architecture pour les échanges entre processus&nbsp;: le <code>RPC</code> (Remote Procedure Call).
			L'idée générale est de permettre d'invoquer une procédure à travers un réseau pour la faire exécuter sur un serveur et récupèrer
			le résultat par le client.</p>
			<p>Il existe une différence de perspective entre une approche RPC et une approche orientée ressource telle que REST. Avec le RPC,
			la conception du service se focalise sur un traitement et sur l'appel à une procédure comme on le ferait dans un langage impératif. 
			Dans une approche orientée ressource, la conception du service se focalise sur l'information et on tend à uniformiser les opérations disponibles pour manipuler
			cette information (les méthodes HTTP <code>GET</code>, <code>PUT</code>, <code>POST</code>, <code>DELETE</code> et <code>PATCH</code> 
			en sont une très bonne illustration).
			Si l'approche orientée ressource peut sembler plus restrictive dans un premier temps, elle est en fait beaucoup 
			plus simple à implémenter et beaucoup plus facile à généraliser.</p>
			<p>Ainsi, une URI doit représenter une ressource et non pas une procédure.</p>
			
			<aside class="warn">
				<p>Le jeu d'URI suivant n'est pas correct du point de vue REST&nbsp;:</p>
				<pre><code class="http">
http://epsi.fr/bordeaux/informatique/i4/etudiants/inscrire?nom=John&amp;prenom=Doe

http://epsi.fr/bordeaux/informatique/i4/etudiants/desinscrire?id=1337

http://epsi.fr/bordeaux/informatique/i4/etudiants/noter?id=1337&amp;module=webservices&amp;note=16

</code></pre>
				<p>Certes il s'agit d'URI informatives pour lesquelles on comprend assez facilement ce qu'elles représentent. 
				Cependant, elles semblent décrire des opérations et sont donc orientées RPC.</p>
			</aside>
		</section>
			
		<section>
			<h2>La représentation</h2>
			<p>Dans une architecture REST, un client et un serveur n'échangent pas une ressource 
			mais des représentations, c'est-à-dire <strong>un ensemble de données relatives à l'état courant d'une ressource</strong>.
			Ainsi, on peut dire que, du point de vue du client, la nature d'une ressource est inconnue puisqu'il ne manipule que
			des URI et des représentations. Lorsqu'un client veut créer une ressource sur le serveur en utilisant par
			exemple la méthode <code>PUT</code>, il ne fournira qu'une représentation de ce qu'il souhaite. Le serveur est libre
			d'utiliser tout ou partie de l'information transmise par le client ou même l'enrichir pour générer la ressource.
			Le serveur peut également choisir les formats de représentation disponibles lors de l'accès à la ressource avec la méthode <code>GET</code>.
			Parmi ces formats, il peut choisir de supporter ou non le format utilisé par le client au moment de la création.</p>
			<p>Une même ressource Web peut avoir plusieurs représentations : une image JPEG, une page HTML, un document XML, un document JSON...
			Si le serveur dispose de plusieurs représentations d'une ressource, il retourne celle qui correspond le mieux aux capacités du client.
			Pour cela le client doit fournir ses préférences. C'est ce que l'on appelle la <strong>négociation de contenu proactive</strong>.
			Nous avons vu que cette négociation se fait en HTTP grâce à des en-têtes particuliers.</p>
			
			<aside>
				<p>Il faut garder à l'esprit que la négociation de contenu ne se limite pas uniquement au format de données (HTML, XML, JSON...).
				La négociation peut également porter sur la langue utilisée dans la représentation.
				</p>
			</aside>
			
			<h2>Les contraintes REST</h2>
			
			<p>Dans le chapitre 5 de sa thèse, Roy Fielding présente les contraintes d'une architecture REST&nbsp;:</p>
			<ul>
				<li>client/serveur</li>
				<li>interface uniforme</li>
				<li>sans état (stateless)</li>
				<li>mise en cache (caching)</li>
				<li>layered system</li>
				<li>code-on-demand</li>
			</ul>
			
			<h3>Client/Serveur</h3>
			
			<p>Cette contrainte ne semble pas en être une tellement nous sommes habitués à interagir
			avec des réseaux informatiques basés sur ce modèle. Pourtant une approche client/serveur
			n'a rien de "naturelle" et il s'agit bien de limiter les rôles que peuvent jouer
			les éléments d'un réseau. Dans cette approche un élément du réseau peut être
			client et/ou serveur. En tant que serveur, il dispose d'un ensemble d'information qu'il
			peut transmettre à la demande à d'autres éléments du réseau qui sont appelés ses clients.</p>
			
			<aside>
				<p>Il existe des modèles de réseau qui ne sont pas basés sur le modèle client/serveur. Par exemple,
				les architectures de <em>micro-services</em> reposent sur un bus de données
				dans lequel un service peut écrire ou lire de l'information sans avoir connaissance
				des autres services.</p>
			</aside>
			
			
			<h3>Interface uniforme</h3>
			
			<p>Si chaque élément d'un réseau dispose de sa propre interface, un client
			devra s'adapter à chaque serveur vers lequel il désire émettre une requête. Pour éviter
			ce problème, il est nécessaire de définir une interface claire et minimaliste à laquelle
			chaque serveur doit se conformer. Pour HTTP, cette interface est composée des méthodes
			(<code>GET</code>, <code>HEAD</code>, <code>PUT</code>, <code>POST</code>, <code>DELETE</code>...),
			des URI et de la possibilité d'échanger des représentations en y associant des méta-informations
			(notamment sur le type de données).</p>
			
			<aside>
				<p>La contrainte de l'interface uniforme entraîne <i>de facto</i> le rejet du style RPC (Remote Procedure Call)
				pour les échanges dans une architecture REST. Contrairement au RPC, une interface uniforme fait 
				portée la sémantique du service sur le contenu de la représentation et dans l'enchaînement des requêtes.</p>
			</aside>
			
			<h3>Sans état (stateless)</h3>
			
			<p>Dans une architecture client/serveur, un serveur ne peut pas mémoriser l'ensemble des échanges
			qu'il a avec ses clients. Pour qu'un réseau soit scalable, le client et le serveur ne doivent
			pas dépendre d'autres informations que celles contenues dans la requête. La requête est auto-suffisante
			pour que le serveur puisse la traiter.</p>
			<p>Une pratique (trop) courante dans le développement d'application Web est de définir une session côté
			serveur qui stocke temporairement des informations issues de requêtes précédentes. Ce mécanisme de session est le
			plus souvent géré grâce à des Cookies. Cette pratique va à l'encontre de la contrainte d'un échange
			sans état.</p>
			
			<aside>
				<p>Cette contrainte est probablement celle qui perturbe le plus les habitudes des développeurs.
				Il est tellement plus simple de concevoir des services en utilisant une session utilisateur
				côté serveur que cette contrainte paraît excessive. Ce que les développeurs oublient,
				ce sont les complications créées par un service avec état (stateful) en exploitation&nbsp;:
				gestion de la montée en charge (ajout de serveur et répartition de charge),
				rigidité dans l'utilisation du service (le client est supposé suivre une succession d'étapes
				pour <i>remplir sa session</i>), bugs dûs à des données manquantes et/ou des pertes de session.</p>
			</aside>
			
			<h3>Mise en cache (caching)</h3>
			
			<p>Un serveur a la responsabilité de fournir au client des informations sur la possibilité
			de conserver une représentation et de la considérer comme valide pendant un certain laps de temps.
			Cette contrainte est malheureusement très largement sous-estimée par les développeurs de services Web alors
			qu'elle permet d'améliorer considérablement les performances d'une application. Il ne faut pas oublier
			que la mise en cache est un mécanisme qui est largement exploité par les éléments "transparents" d'Internet
			comme les proxies pour améliorer l'efficacité des échanges.</p>
			<p>La <a href="http://tools.ietf.org/html/rfc7234">RFC 7234</a> est entièrement consacrée à la mise en cache avec HTTP/1.1.
			La gestion du cache est assurée par les en-têtes de réponse <a href="http://tools.ietf.org/html/rfc7234#section-5.3"><code>Expires</code></a>
			et <a href="http://tools.ietf.org/html/rfc7234#section-5.2"><code>Cache-Control</code></a> mais
			aussi par les en-têtes de validation 
			<a href="http://tools.ietf.org/html/rfc7232#section-2.2"><code>Last-Modified</code></a> et 
			<a href="http://tools.ietf.org/html/rfc7232#section-2.3"><code>ETag</code></a> 
			(ces derniers ont été décrits dans les cas d'utilisation de HTTP).
			</p>
			
			<h3>Layered system</h3>
			
			<p>Un réseau doit être stratifié en couches. Un élément du réseau ne peut dialoguer qu'avec 
			ses voisins immédiats, c'est-à-dire les composants appartenant aux couches adjacentes. Ainsi si un client
			veut envoyer une requête à un serveur qui n'est pas localisé dans une couche adjacente, il va devoir
			passer par des intermédiaires. Pour Internet, les intermédiaires sont les <strong>proxies</strong> et les 
			<strong>gateways</strong>.</p>

			<h3>Code on demand</h3>
			
			<p>Il s'agit d'une contrainte optionnelle de l'architecture REST. Un client peut étendre ses fonctionnalités
			en téléchargeant du code exécutable. Le code-on-demand est trés largement utilisé dans le Web pour les humains 
			avec notamment le support de JavaScript pour étendre les fonctionnalités du navigateur Web.</p>

			<h2>Hypermédia</h2>
			
			<p>Dans sa thèse de 2000, Roy Fielding cite une contrainte d'interface&nbsp;:</p>
			<blockquote>hypermedia as the engine of application state</blockquote>
			<p>Cette contrainte est devenue célèbre et est parfois abrégée en <strong>HATEOAS</strong>.
			Alors que le lecteur s'attend à une explication, Roy Fielding ne revient pas directement et 
			explicitement sur cette contrainte. Depuis, la notion d'hypermédia est associée à 
			REST mais est trop rarement explicitée.</p>
			<p>Un site Web ou un service Web n'est pas qu'un ensemble d'URI permettant d'identifier
			des ressources et de les manipuler à travers des représentations. Les représentations sont
			également des hypermédias&nbsp;: elles contiennent des liens vers d'autres ressources.</p>
			
			<h3>Les formats hypermédias</h3>
			<p>Lorsque l'on prend l'exemple du Web, le format hypermédia le plus courant pour une représentation
			est le HTML. Avec les balises <code>a</code>, <code>form</code> et <code>link</code>, il est possible d'inclure
			des liens afin de guider le client dans les choix d'interaction autorisés par le serveur.
			Lorsque l'on dit couramment que l'on <em>navigue</em> ou que l'on <em>surfe</em> sur le Web,
			on décrit les actions rendues possibles par le fait que HTML est un format hypermédia.</p>
			
			<p>Pour l'implémentation de services Web, on préfèrera d'autres langages que HTML&nbsp;:
			généralement XML et JSON. En effet, ces langages sont plus <em>neutres</em> que HTML
			qui ajoute une sémantique de structuration documentaire. Cependant, XML et JSON ne sont pas
			par défaut des langages hypermédias. Il n'existe pas de support natif pour les liens
			dans ces formats. Soit le client doit s'adapter pour comprendre la manière dont le serveur
			inclut le support de l'hypermédia, soit il faut avoir recours à des extensions.
			Pour le XML, le support de l'hypermedia peut se faire grâce à l'extension 
			<a href="http://www.yoyodesign.org/doc/w3c/xlink/index.html"><strong>XLink</strong></a>
			et pour le JSON grâce au format <a href="http://stateless.co/hal_specification.html"><strong>HAL</strong></a> 
			(Hypertext Application Language).</p>
						
			<h3>L'en-tête Link</h3>
			<p>L'en-tête <code>Link</code> (décrit dans la <a href="http://tools.ietf.org/html/rfc5988">RFC 5988</a>)
			permet au serveur de spécifier un lien et le type de relation. Il se présente sous le format suivant &nbsp;:</p>
			
			<pre><code class="http">Link: &lt;URI&gt;;[attributs]</code></pre>
			
			<p>Parmi les attributs possibles, on trouve principalement <code>rel</code> qui permet de spécifier
			le type de la relation et <code>title</code> qui fournit une description textuelle du lien.</p>
			
			<pre><code class="http">Link: &lt;<script>document.write(window.location)</script>&gt;;rel="self";title="REST"</code></pre>
			
			<aside>
				<p>Le type de relation indiqué par l'attribut <code>rel</code> est soit un nom défini par le 
				<a href="http://www.iana.org/assignments/link-relations/link-relations.xhtml">registre du IANA</a>
				soit une URI pour un type propre au serveur.</p>
			</aside>
			
			<p>Avec l'en-tête <code>Link</code>, il est possible d'exprimer des liens entre ressources
			hors de la représentation (et donc dans des réponses ne contenant pas de <i>payload</i>).
			Cependant, l'en-tête <code>Link</code> est encore rarement utilisé.</p>
			
			
			<!--  hypermedia comme gestion d'état applicatif -->
			<h3>Les apports de l'hypermédia</h3>
			
			<p>L'hypermédia a pour objectif de déléguer au serveur la responsabilité de guider
			le client dans ce qu'il est possible de réaliser. Au client de choisir ce qu'il souhaite faire
			parmi les possibilités qui lui sont proposées.
			Cette pratique permet au client de ne connaître que le minimum requis pour utiliser le service.
			L'hypermédia n'est pas une technologie ni une méthode de développement. Il est le résultat de la
			conception d'un service respectant les contraintes REST.</p>
			<p>Ainsi, grâce à l'hypermédia, un client ne sera pas dépendant des règles de construction
			des URI. Il doit connaître un point d'entrée du service mais le serveur doit lui fournir
			dans les représentations (et/ou grâce à l'en-tête <code>Link</code>) les URI à utiliser
			pour accéder aux autres ressources. Cette pratique permet un découplage entre l'implémentation du client
			et les choix d'implémentation et de déploiement du service.</p>
			<p>En spécifiant au client les liens possibles dans ses réponses, le serveur
			définit un workflow qui décrit les états successifs du client. Avec l'hypermédia, il devient
			possible de modéliser des interactions client/serveur complexes par un enchaînement de requête/réponse.
			On peut donc bien dire, à la suite de Roy Fielding, que l'hypermédia permet de décrire une machine à état
			d'une application formée par l'intéraction entre un client et un serveur.</p>

			<h2>REST&nbsp;: ça veut dire quoi&nbsp;?</h2>
			
			<p>REST est un acronyme pour <strong>Representational State Transfer</strong>.</p>
			<p>Il s'agit bien d'une architecture dont l'objectif et de transférer des états sous la forme de représentation.</p>

			<h2>Les services Web RESTful</h2>
			
			<p>Les services Web RESTful (appelés également API Web) ne sont fondamentalement pas différents des sites Web traditionnels.
			Ils obéissent aux mêmes contraintes d'architecture. La différence est une différence d'utilisation. 
			<p>Dans le cas d'un site Web, le travail du programme client consiste à présenter l'information à un être humain.
			L'interprétation des données est donc de la responsabilité de l'être humain et c'est bien lui qui va sélectionner 
			tel ou tel lien hypermédia selon ses objectifs ou ses goûts.</p>
			<p>Pour un service Web, on attend le plus souvent du logiciel client qu'il sache, non seulement exploiter les URI 
			et invoquer correctement les méthodes HTTP, mais également adapter son comportement en fonction du contenu de l'information échangée.
			Cette capacité à analyser le contenu des représentations doit être favorisée par le serveur qui à la charge
			de définir la sémantique de protocole et la sémantique applicative (ces notions sont empruntées à l'ouvrage 
			<strong>RESTful Web APIs</strong> - O'Reilly 2013).</p>
			
			<dl>
				<dt>Sémantique de protocole</dt>
				<dd>Il s'agit de la compréhension que l'on peut avoir du service par la connaissance du format des URI et par
				les méthodes HTTP autorisées sur ces URI. Généralement cette compréhension est suffisante pour un être humain
				afin de tester un service. Par contre l'implémentation d'un client basé uniquement sur la sémantique
				de protocole est possible mais reste limitée, notamment pour prendre en compte les évolutions du service. Un navigateur Web est un bon
				exemple de logiciel qui se limite à la sémantique de protocole en utilisant principalement le support
				hypermédia du HTML pour présenter à un utilisateur la liste des liens possibles.</dd>

				<dt>Sémantique applicative</dt>
				<dd>La sémantique applicative porte sur la signification des représentations échangées et sur la signification des liens entre
				ces représentations. Si une API Web définit un lien entre deux ressources comme étant de type <em>caused by</em>, cela n'a <i>a priori</i>
				aucune signification pour un logiciel client. La sémantique applicative est généralement décrite dans une documentation en ligne.
				Des formats de description traitables par une machine commencent à voir le jour et à être utilisés (par exemple le <a href="http://www.w3.org/TR/json-ld/">JSON-LD</a>).</dd>
			</dl>
			
			<p>Concevoir une API Web digne de ce nom nécessite donc de réduire au minimum le niveau de compréhension du client
			nécessaire pour l'utiliser. Minimiser l'effort nécessaire à la maîtrise de la sémantique de protocole est la tâche la plus simple si l'on
			prend la peine d'utiliser un format hypermédia de représentation (HTML, <a href="http://stateless.co/hal_specification.html">HAL+JSON</a>, 
			<a href="http://stateless.co/hal_specification.html">HAL+XML</a>). En ce qui concerne la sémantique applicative, le plus efficace
			consiste à réutiliser ce qui a déjà été défini par d'autres. &Agrave; ce titre, le recours à des formats proches des <a href="http://microformats.org/wiki/">
			microformats</a> ou des <a href="http://schema.org/">schémas Web</a> permettent de créer un standard de fait pour la représentation de certaines ressources. Enfin,
			pour une API Web qui souhaiterait utiliser HTML comme format hypermédia de représentation, il existe trois techniques très simples pour introduire
			une sémantique applicative en HTML&nbsp;: les <a href="http://microformats.org/wiki/">microformats</a>, 
			les <a href="http://en.wikipedia.org/wiki/Microdata_%28HTML%29">microdata</a> ou <a href="http://www.w3.org/TR/rdfa-lite/">RDFa</a>.</p>
			
			<aside>
				<p>Il est également possible de définir son propre type de contenu en définissant un nouveau type MIME. Les formats de type <code>application/vnd.xxxx</code> désignent
				des formats spécifiques qui ne sont pas forcément déclarés dans <a href="http://www.iana.org/assignments/media-types/media-types.xhtml">le registre du IANA</a>.
				L'avantage de créer son propre type de contenu est que l'on peut définir simultanément la sémantique de protocole et la sémantique applicative (en fournissant
				le format autorisé des représentations).</p>
			</aside>
			
			<!--
			HTML 5 Web storage : http://www.w3schools.com/html/html5_webstorage.asp
			MIME list: http://www.iana.org/assignments/media-types/media-types.xhtml
			http://microformats.org/wiki/hcard
			microdata
			http://schema.org/
			RDFa (http://www.w3.org/TR/rdfa-lite/)
			Faire la différence entre sémantique de protocole (décrit les URI, le format de construction et les méthodes autorisées) et sémantique applicative
			(décrit la signification des réprésentations échangées). Normalement il n'est pas nécessaire de fournir une documentation de la sémantique du protocole
			si ce dernier supporte l'hypermédia.
			profile = description des liens (rel) + descripteur sémantique
			http://www.google.com/webmasters/tools/richsnippets
			http://www.w3.org/TR/json-ld/
			 -->
		</section>
	</article>
	
	<article class="exercice">
		<h2>Exercice&nbsp;: Un service de paiement de factures</h2>
		
		<p>&Eacute;tant donné le workflow suivant décrivant le paiement d'une facture&nbsp;:</p>
		<figure>
			<img src="assets/diagramme_activite_paiement_facture.svg" alt="Diagramme d'activité de paiement de facture" />
		</figure>
		<p>Les activités sont&nbsp;:</p>
		<dl>
			<dt>créer facture</dt>
			<dd>Création d'un document identifiant les coordonnées bancaires du créditeur et le montant à payer.</dd>

			<dt>autoriser paiement</dt>
			<dd>Le débiteur indique ses informations de paiement (numéro de carte de paiement, date limite de validité
			de la carte et cryptogramme de sécurité). Le client effectue une demande auprès de l'organisme bancaire pour savoir
			si la transaction est autorisée. L'organisme bancaire fournit un numéro d'autorisation permettant
			d'identifier la transaction.</dd>

			<dt>capturer paiement</dt>
			<dd>Si l'autorisation s'est bien passée, le client réalise une <em>capture</em>, c'est-à-dire qu'il
			demande à l'organisme bancaire d'enregister le paiement et d'effectuer le transfert du compte du
			débiteur vers le compte du créditeur.</dd>
		</dl>
		
		<p>Décrivez la réalisation d'une API Web RESTful par des exemples de requêtes/réponses HTTP.</p>
		<p>Décrivez également des scénarios alternatifs&nbsp;:</p>
		<ul>
			<li>L'autorisation échoue car les informations bancaires fournies sont incorrectes</li>
			<li>L'autorisation échoue car le client ne dispose pas du crédit suffisant sur son compte.</li>
		</ul>

		<h2>Implémentation</h2>
		<p>Voici un exemple d'implémentation d'après les choix réalisés en cours.</p>
		
		<p>Pour la requête de création, nous partons du principe que le service à réaliser n'est pas un système
		de gestion de factures. Il n'est donc pas nécessaire d'appliquer d'éventuelles règles légales concernant
		la numérotation des factures. Le client est responsable de fournir l'URI de la ressource de la nouvelle facture
		lors de la création (utilisation de la méthode <code>PUT</code>).</p>

		<figure>
			<figcaption>Requête de création d'une facture</figcaption>
			<pre><code class="http">PUT /factures/1984 HTTP/1.1
Host: mon-serveur.com
Content-type: application/xml
Content-length: 605

&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;facture
    xmlns="http://mon-serveur.com/facture"
    xsi:schemaLocation="http://mon-serveur.com/facture.xsd"&gt;
    
    &lt;dateFacture&gt;14/11/2014&lt;/dateFacture&gt;

    &lt;montant monnaie="EUR"&gt;114&lt;/montant&gt;

    &lt;client&gt;
        &lt;prenom&gt;Jean&lt;/prenom&gt;
        &lt;nom&gt;Dalbant&lt;/nom&gt;
    &lt;/client&gt;
    
    &lt;adresseFacturation&gt; 
        &lt;numero&gt;24&lt;/numero&gt;
        &lt;voie&gt;rue de mon voisin&lt;/voie&gt;
        &lt;zipcode&gt;31000&lt;/zipcode&gt;
        &lt;ville&gt;Bordeaux&lt;/ville&gt;
        &lt;pays&gt;France&lt;/pays&gt;
    &lt;/adresseFacturation&gt;
    
    &lt;crediteur&gt;
        &lt;iban&gt;BE43068999999501&lt;/iban&gt;
    &lt;/crediteur&gt;
&lt;/facture&gt;

</code></pre>
		</figure>
		
		<figure>
			<figcaption>Réponse pour la création d'une facture</figcaption>
			<pre><code class="http">HTTP/1.1 201 Created
Location:  http://www.mon-serveur.com/factures/1984
Link: &lt;http://www.mon-serveur.com/factures/1984/paiement&gt;; rel="payment"; title="Paiement"
</code></pre>
		</figure>
		
		<p>Afin d'utiliser une sémantique pré existante pour notre service, nous pouvons choisir de
		nous baser sur les schémas Web définis sur <a href="http://schema.org">schema.org</a>.
		Il n'existe pas à proprement parler de schéma pour une facture, mais nous disposons
		d'une <a href="https://schema.org/PayAction"><code>PayAction</code></a>. Ainsi, une adaptation
		de ce schéma donnerait&nbsp;:</p>
		
		<figure>
			<figcaption>Requête d'une PayAction</figcaption>
			<pre><code class="http">PUT /PayAction/1984 HTTP/1.1
Host: mon-serveur.com
Content-type: application/xml
Content-length: 565

&lt;PayAction 
     xmlns="http://schema.org/PayAction"
     xsi:schemaLocation="http://mon-serveur.com/xsd/PayAction.xsd"&gt;
  &lt;purpose&gt;
    &lt;name&gt;CLI-23234584391&lt;/name&gt;
    &lt;description&gt;Commande sur le site Internet trouvetout.com&lt;/description&gt;
    &lt;url&gt;https://trouvetout.com/bill/CLI-23234584391&lt;/url&gt;
  &lt;/purpose&gt;
  &lt;price priceCurrency="EUR"&gt;114&lt;/price&gt;
  &lt;recipient&gt;
    &lt;name&gt;trouvetout Inc.&lt;/name&gt;
    &lt;iban&gt;BE43068999999501&lt;/iban&gt;
  &lt;/recipient&gt;
  &lt;agent&gt;
    &lt;honorificPrefix&gt;M.&lt;/honorificPrefix&gt;
    &lt;givenName&gt;Jean&lt;/givenName&gt;
    &lt;name&gt;Dalbant&lt;/name&gt;
  &lt;/agent&gt;
&lt;/PayAction&gt;
</code></pre>
		</figure>

		<figure>
			<figcaption>Réponse pour une PayAction</figcaption>
			<pre><code class="http">HTTP/1.1 201 Created
Location:  http://www.mon-serveur.com/PayAction/1984
Link: &lt;http://www.mon-serveur.com/PayAction/1984/payment&gt;; rel="payment"; title="Paiement"
</code></pre>
		</figure>
		
		<p>Pour le paiement, le client doit suivre le lien typé <code>payment</code> fourni dans l'en-tête de la réponse.
		</p>
		
		<figure>
			<figcaption>Requête de demande d'autorisation</figcaption>
			<pre><code class="http">POST /PayAction/1984/payment HTTP/1.1
Host: mon-serveur.com
Content-type: application/x-www-form-urlencoded; charset=utf-8
Content-length: 148

cardNumber=1111222233334444&amp;expiryDate=12/<script type="text/javascript">document.write(new Date().getFullYear())</script>&amp;securityCode=123
</code></pre>
		</figure>
		
		<figure>
			<figcaption>Réponse pour la demande d'autorisation</figcaption>
			<pre><code class="http">HTTP/1.1 307 Temporary Redirect
Location: http://www.mon-serveur.com/PayAction/1984/payment/456938103394

</code></pre>
		</figure>
		
		<p>Une réponse avec le code 307, suggère au client que le paiement ne sera terminé que si il refait la même
		requête que précédemment à la nouvelle URI donnée par l'en-tête de réponse <code>Location</code>. Dans notre exemple,
		le serveur fournit une URI qu'il identifiera comme une URI de ressource valide pour une capture.</p>
		
		<aside>
			<p>Il n'est pas obligatoire d'utiliser un code de redirection. On peut même considéré que pour des raisons
			de sécurité, on ne désire pas que le client envoie deux fois les données bancaires. Dans, ce cas, on
			peut opter pour une autre cinématique dans laquelle le serveur renvoie à nouveau un lien vers l'URI de capture.</p>
			<figure>
				<figcaption>Réponse pour la demande d'autorisation sans redirection</figcaption>
				<pre><code class="http">HTTP/1.1 200 OK
Link: &lt;http://www.mon-serveur.com/PayAction/1984/payment/456938103394&gt;;rel="urn:epsi:capture"

</code></pre>
			</figure>
			<p>Comme il n'existe pas de type de relation dans le <a href="http://www.iana.org/assignments/link-relations/link-relations.xhtml">registre du IANA</a>
			pour décrire un lien vers une capture, on utilise une URI pour décrire la relation : urn:epsi:capture</p>
		</aside>

	</article>
	
	<article class="exercice">
		<h2>Exercice&nbsp;: Le service d'achat en ligne</h2>
		
		<p>On désire mettre en ligne un catalogue de produits parmi lesquels un client peut constituer un panier d'achat.</p>

		<p>Les cas d'utilisation définis sont&nbsp;:</p>
		<ul>
			<li>L'utilisateur consulte la liste des articles du catalogue</li>
			<li>L'utilisateur consulte le détail d'un produit</li>
			<li>L'utilisateur ajoute un produit à son panier d'achat</li>
			<li>L'utilisateur supprimer un produit de son panier d'achat</li>
			<li>L'utilisateur valide son panier pour le paiement en ligne</li>
		</ul>
		<p>Décrivez la réalisation d'une API Web RESTful par des exemples de requêtes/réponses HTTP.</p>
		

		<h2>Implémentation</h2>
		<p>Voici un exemple d'implémentation d'après les choix réalisés en cours.</p>
		
		<p>Pour la consultation de la liste de produits du catalogue, on opte pour une représentation au format HAL+JSON.
		Cela permet d'introduire facilement un lien vers chaque produit du catalogue&nbsp;:</p>
		
		<figure>
			<figcaption>Requête pour connaître la liste des produits du catalogue</figcaption>
			<pre><code class="http">GET /products HTTP/1.1
Host: www.mon-serveur.com
Accept: application/hal+json

</code></pre>
		</figure>

		<figure>
			<figcaption>Réponse contenant la liste des produits du catalogue</figcaption>
			<pre><code class="http">HTTP/1.1 200 OK
Content-type: application/hal+json; charset=utf-8
Content-length: 407

{
  "_links": {
    "self": { "href": "/products" },
    "next": { "href": "/products?page=2" }
  },
  "_embedded": {
    "product": [
      {
        "_links": {
          "self": { "href": "/products/3958302947394" }
        },
        "name": "un super produit"
      },
      {
        "_links": {
          "self": { "href": "/products/495049347238" }
        },
        "name": "un autre super produit"
      }
    ]
  }
}
</code></pre>
		</figure>
		
		<p>La gestion du panier d'achat est en fait une logique du client. En effet, suivre REST impose de se contraindre à concevoir un service dont les requêtes sont sans état. Si on désire conserver un état
		du client au fur et à mesure de la navigation, alors cela doit être au client de le faire. Donc l'API Web n'a pas besoin de fournir une ressource pour à un panier d'achat.
		Si le client désire implémenter une telle logique, il peut tout simplement conserver une liste en mémoire et soumettre au moment de l'achat
		l'ensemble des articles. Dans ce cas, l'API Web doit se contenter de fournir la possibilité de créer une ressource de commande d'articles par exemple.
		Dans le cas d'un site HTML, il est tout à fait possible de gérer un panier côté client à l'aide de 
		<a href="http://www.w3schools.com/html/html5_webstorage.asp">l'API HTML 5 <strong>Local Storage</strong> ou <strong>Session Storage</strong></a>.
		</p>
		
	</article>
	
	<article class="exercice">
		<h2>Exercice&nbsp;: Un service de réservation de billet</h2>
		
		<p>On désire mettre en ligne un service de réservation de billets de concert. Le service ne gère pas de base de données des utilisateurs&nbsp;: un utilisateur est simplement identifié par un pseudo au moment de la réservation.</p>
		<p>Les cas d'utilisation définis sont&nbsp;:</p>
		<ul>
			<li>L'utilisateur réserve une place pour un concert avec un pseudo</li>
			<li>L'utilisateur annule sa réservation</li>
			<li>L'utilisateur confirme sa réservation</li>
			<li>Le gestionnaire du site consulte la liste des réservations pour un concert</li>
			<li>Le gestionnaire du site consulte la liste des réservations confirmées pour un concert.</li>
		</ul>
		<p><strong>Attention, un utilisateur qui a confirmé sa réservation ne peut plus l'annuler !</strong></p>
		<p>Décrivez la réalisation d'une API Web RESTful par des exemples de requêtes/réponses HTTP.</p>
	</article>
		
	<article>
		<h2>Références</h2>

		<h3>Sites Web &amp; articles</h3>
		<dl>
			<dt>REST cookbook</dt>
			<dd><a class="explicit" href="http://restcookbook.com/">http://restcookbook.com/</a></dd>

			<dt>Une étude de cas très complète (commander un café en REST)</dt>
			<dd><a class="explicit" href="http://www.infoq.com/articles/webber-rest-workflow">http://www.infoq.com/articles/webber-rest-workflow</a></dd>

			<dt>Le modèle de maturité de Richardson des services Web RESTful</dt>
			<dd><a class="explicit" href="http://martinfowler.com/articles/richardsonMaturityModel.html">http://martinfowler.com/articles/richardsonMaturityModel.html</a></dd>

		</dl>
	
		<h3>Livres</h3>
		<dl>
			<dt><a href="http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm">Architectural Styles and the Design of Network-based Software Architectures</a></dt>
			<dd>Roy Fielding - University of California, Irvine 2000 (La thèse de doctorat incluant la présentation de REST)</dd>

			<dt><a href="http://shop.oreilly.com/product/0636920028468.do">RESTful Web APIs</a></dt>
			<dd>Leonard Richardson, Mike Amundsen, Sam Ruby - O'Reilly 2013</dd>

			<dt><a href="http://shop.oreilly.com/product/9780596529260.do">RESTful Web Services</a></dt>
			<dd>Leonard Richardson &amp; Sam Ruby - O'Reilly 2007</dd>
			
			<dt><a href="http://restinpractice.com/book/book.html">REST in Practice</a></dt>
			<dd>Jim Webber, Savas Parastatidis, Ian Robinson - O'Reilly Media 2010</dd>
		</dl>

		<h3>Applications de démo</h3>
		<dl>
			<dt><a href="http://rest-bookmarks.herokuapp.com/">REST bookmarks</a></dt>
			<dd>Une application de démo de gestion de marque-pages (le code source en Java est disponible sur <a href="https://github.com/spoonless/rest-bookmarks">GitHub</a>)</dd>

			<dt><a href="http://www.youtypeitwepostit.com">You type it, we post it!</a></dt>
			<dd>Une application de démo issue de l'ouvrage <strong>RESTful Web APIs</strong> (le code source pour Node.js est disponible sur <a href="https://github.com/RESTful-Web-APIs/example-code">GitHub</a>)</dd>
		</dl>
		
	</article>

</body>
</html>
